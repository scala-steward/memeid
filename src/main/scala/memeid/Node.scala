package memeid.node

import java.net.{InetAddress, NetworkInterface}
import java.security.MessageDigest

import scala.collection.JavaConverters._
import scala.util.Random

import cats.effect._
import cats.syntax.apply._
import cats.syntax.functor._
import cats.syntax.show._
import cats.{Eval, Show}

import memeid.bits._

trait Node[F[_]] {
  // The 16-bit clock sequence for this node
  def clockSequence: F[Short]

  // A collection of system addresses
  def addresses: F[Set[String]]

  // The system properties
  def properties: F[Map[String, String]]

  // The node id
  def nodeId: F[Long]
}

object Node {
  // Clock sequence: https://tools.ietf.org/html/rfc4122#section-4.1.5
  //
  //   The clock sequence MUST be originally (i.e., once in the lifetime of
  //   a system) initialized to a random 16-bit number to minimize the correlation
  //   across systems.
  //
  private val clockSeq: Eval[Short] = Eval.now(new Random().nextInt(Short.MaxValue + 1).toShort)

  // System property data sources
  //
  //   "items such as the computer's name and the name of the
  //    operating system, while not strictly speaking random, will help
  //    differentiate the results from those obtained by other systems."
  private def nodeIdDataSources = List(
    "java.vendor",
    "java.vendor.url",
    "java.version",
    "os.arch",
    "os.name",
    "os.version"
  )

  // TODO: memoize this function, we don't want to compute node id every time we generate a v1 UUID

  // Node IDs that do not identify the host: https://tools.ietf.org/html/rfc4122#section-4.5
  //
  //  "Obtain a 47-bit cryptographic quality random number, with the least significant bit
  //   of the first octet of the Node-ID set to one."
  def makeNodeId(addresses: Set[String], properties: Map[String, String]): Long = {
    val digest = MessageDigest.getInstance("MD5")
    val dataForDigest = nodeIdDataSources.foldLeft(addresses)({
      case (acc, key) =>
        properties.get(key) match {
          case None    => acc
          case Some(v) => acc + v
        }
    })
    dataForDigest.foreach({ d =>
      digest.update(d.getBytes)
    })
    // "A better solution is to obtain a 47-bit cryptographic quality random
    //  number and use it as the low 47-bits of the Node-ID, with the least
    //  significant bit of the first octet of the Node-ID set to one.
    //  This bit is the unicast/multicast bit, which will never be set in IEEE 802
    //  addresses obtained from network cards.  Hence, there can never be a
    //  conflict between UUID's generated by machines with and without network
    //  cards."
    //
    // Note: "first" as in first in network transmission order, so is referring to the least significant octet.
    val multicastBit = List(0x00, 0x00, 0x00, 0x00, 0x00, 0x01)
    val bytes = digest.digest
      .take(6)
      .zip(multicastBit)
      .map({
        case (d, b) => (d | b).toByte
      })
    Bits.fromBytes(List(0: Byte, 0: Byte) ++ bytes)
  }

  def fromClockSequence[F[_]](clkSeq: F[Short])(
      implicit
      S: Sync[F]
  ): Node[F] = new Node[F] {
    def clockSequence: F[Short] = clkSeq

    def addresses = S.delay(Sys.getNetworkInterfaces ++ Sys.getLocalInterfaces)

    def properties = S.delay(Sys.getProperties)

    // todo: should be only computed once
    def nodeId =
      (addresses, properties).mapN({
        case (addr, prop) => makeNodeId(addr, prop)
      })
  }

  implicit def apply[F[_]: Sync]: Node[F] = fromClockSequence(Sync[F].pure(clockSeq.value))
}

object Sys {
  implicit val showInet: Show[InetAddress] = Show.fromToString

  def getNetworkInterfaces: Set[String] = {
    val localHost     = InetAddress.getLocalHost
    val hostName      = localHost.getCanonicalHostName
    val baseAddresses = Set(localHost.show, hostName)
    NetworkInterface.getNetworkInterfaces.asScala.foldLeft(baseAddresses)({
      case (addrs, ni) =>
        addrs ++ ni.getInetAddresses.asScala.map(_.show).toSet
    })
  }

  def getLocalInterfaces: Set[String] = {
    val localHost = InetAddress.getLocalHost
    val hostName  = localHost.getCanonicalHostName
    InetAddress.getAllByName(hostName).map(_.show).toSet
  }

  def getProperties: Map[String, String] = {
    val props = System.getProperties
    val keys  = props.stringPropertyNames
    keys.asScala.map(k => k -> props.getProperty(k)).toMap
  }
}
